meta_bool <- str_detect(string,regexpression)
str_replace(string[meta_bool],regexpression, "\\1")
}
chordpro_meta_all <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
out2 <- map(tags, ~chordpro_meta(string,.x))
names(out2) <- tags
out2
}
chordpro_meta_remove <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
remove <- str_detect(string,paste0("(",paste0("\\{",tags,":",collapse = "|"),")"))
string[!remove]
}
chordpro_environment <- function(string,environment_name){
start_bool <- str_detect(string,paste0("\\{start_of_",environment_name))
end_bool <- str_detect(string,paste0("\\{end_of_",environment_name))
c(which(start_bool),which(end_bool))
}
chordpro_environment_all <- function(string){
envs <- c("chorus","verse","tab","grid")
out2 <- map(envs, ~chordpro_environment(string,.x))
names(out2) <- envs
out2
}
# Chunk 7
dirs <- list.dirs("songs_cho/",full.names = TRUE)
rmd_file_nr = 0
for (dir in dirs){
yml <- list.files(dir,pattern = "(.yaml|.yml)",full.names = TRUE)
if(length(yml) > 0){
meta <- read_yaml(yml)
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
dir_bn <- basename(dir)
fileConn<-file(paste0("songs_md2/",rmd_file_nr_chr,dir_bn,".Rmd"))
paste("#",meta$title) %>%
writeLines(fileConn)
songs <- list.files(dir, pattern = ".txt",full.names = TRUE)
songs_bn <- basename(songs)
# gives each file an arbitary number
songs_numeric <- map_dbl(songs_bn,~mean(utf8ToInt(.x)))
names(songs_numeric) <- songs
songs_numeric <- sort(songs_numeric)
songs <- names(songs_numeric)
for (song in songs){
song_bn <- basename(song)
print(song_bn)
song_rl <- song %>%
readLines(warn = FALSE)
chordlines_bool <- song_rl %>%
str_detect("\\[")
# Take only lines where subsequent line is not a chord line
chordlines_bool <- chordlines_bool & lead(!chordlines_bool) & lead(str_length(song_rl)>0)
songlines_subsequent_bool <- lag(chordlines_bool,1,default = FALSE)
chordlines <- song_rl[chordlines_bool]
songlines_subsequent <- song_rl[songlines_subsequent_bool]
songlines_new <- map2_chr(chordlines,songlines_subsequent,function(chordline,songline){
locs <- str_locate_all(chordline,"\\[\\w+\\]")[[1]]
# print(locs)
delta_acc = 0
for(idx in 1:nrow(locs)){
# print(idx)
start <- locs[idx,1]
end <- locs[idx,2]
chord <- str_sub(chordline,start,end)
start_insert <- start + delta_acc
if(idx>1){
} else{
songline_out <- songline
}
songline_out <- addchord(songline_out,start_insert,chord)
delta_acc <- delta_acc+ (end-start+1)
}
songline_out
})
song_rl[songlines_subsequent_bool] <- songlines_new
song_modified <- song_rl[!chordlines_bool]
chordpro_meta_l <- chordpro_meta_all(song_modified)
song_modified <- chordpro_meta_remove(song_modified)
chordpro_environment_l <- chordpro_environment_all(song_modified)
songtitle <- paste(chordpro_meta_l$title,chordpro_meta_l$artist, sep = " - ")
song_modified[chordpro_environment_l$chorus[1]] <- "**Chorus:**"
song_modified[chordpro_environment_l$chorus[2]] <- ""
song_modified[chordpro_environment_l$verse[1]] <- ""
song_modified[chordpro_environment_l$verse[2]] <- ""
song_modified[chordpro_environment_l$tab[1]] <- "```{}"
song_modified[chordpro_environment_l$tab[2]] <- "```"
song_modified[chordpro_environment_l$grid[1]] <- "```{}"
song_modified[chordpro_environment_l$grid[2]] <- "```"
# Add the class "show-chords" to lines with chords
haschords <- str_detect(song_modified,"\\[")
song_modified[haschords] <- paste0("<p class='song show-chords'>",song_modified[haschords],"</p>")
codechunk <- str_detect(song_modified,"```")
# Add an extra backslash to lines with no chords to force linebreak
song_modified[!haschords & !codechunk] <- paste0(song_modified[!haschords & !codechunk],"\\")
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
fileConn<-file(paste0("songs_md2/",paste0(rmd_file_nr_chr, str_replace(song_bn,".txt",".Rmd"))))
song_modified %>%
prepend(paste("##", songtitle)) %>% # TODO: add other metadata
str_replace_all("(\\[(\\w+)\\])","<span class='chord'>\\2</span>") %>%
writeLines(fileConn)
close.connection(fileConn)
}
}
}
# Chunk 1
title: ""
pagetitle: "Songs"
site: bookdown::bookdown_site
documentclass: book
link-citations: yes
---
# Chunk 2
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, dev.args=list(bg = "transparent"))
# Chunk 3
output <- knitr::opts_knit$get("rmarkdown.pandoc.to")# html / latex / docx
if(output == "html"){
pander::pandoc.header("Songs {-}",1)
pander::pandoc.image("misc/title.png")
}
# Chunk 4
file.create("docs/.nojekyll")
suppressMessages(library(tabr))
suppressMessages(library(dplyr))
suppressMessages(library(purrr))
suppressMessages(library(ggplot2))
suppressMessages(library(stringr))
suppressMessages(library(gridExtra))
suppressMessages(library(cowplot))
suppressMessages(library(yaml))
test <- TRUE
# Chunk 5
# A wrapper around tabr::plot_chord() which allows multiple chords and styles them in my specific way (4 columns, transparent background etc.)
plot_chords <- function(chords){
# Get the maximum fret-delta of all chords
delta_max <- map_int(chords,function(x){
v <- suppressWarnings(as.integer(str_split(x,"",simplify = TRUE)))
max(v,na.rm = TRUE)-min(v, na.rm = TRUE)
}) %>%
max()
# Make a list of all chord plots
plots <- imap(chords,function(x,y){
v <- min(suppressWarnings(as.integer(str_split(x,"",simplify = TRUE))),na.rm = TRUE)
plot_chord(x,
labels = NULL,
fret_range = c(v,v+delta_max), # so that all chords span the same nr of frets
point_size = 4,
label_size = 3) +
labs(tag = y) +
theme(
panel.background = element_rect(fill = "transparent"), # The theme
plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
)
})
chordnames <- map(chords, ~.x[2])
plot_grid(plotlist = plots,ncol = 4)
}
# Chunk 6
# Transform all songs in songs_txt into markdown files
addchord <- function(string,pos,chord){
paste0(substr(string, 1, pos-1), chord, substr(string, pos, nchar(string)))
}
chordpro_meta <- function(string,metatag){
regexpression <- paste0("\\{",metatag,":\\s(.+)\\}")
meta_bool <- str_detect(string,regexpression)
str_replace(string[meta_bool],regexpression, "\\1")
}
chordpro_meta_all <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
out2 <- map(tags, ~chordpro_meta(string,.x))
names(out2) <- tags
out2
}
chordpro_meta_remove <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
remove <- str_detect(string,paste0("(",paste0("\\{",tags,":",collapse = "|"),")"))
string[!remove]
}
chordpro_environment <- function(string,environment_name){
start_bool <- str_detect(string,paste0("\\{start_of_",environment_name))
end_bool <- str_detect(string,paste0("\\{end_of_",environment_name))
c(which(start_bool),which(end_bool))
}
chordpro_environment_all <- function(string){
envs <- c("chorus","verse","tab","grid")
out2 <- map(envs, ~chordpro_environment(string,.x))
names(out2) <- envs
out2
}
# Chunk 7
dirs <- list.dirs("songs_cho/",full.names = TRUE)
rmd_file_nr = 0
for (dir in dirs){
yml <- list.files(dir,pattern = "(.yaml|.yml)",full.names = TRUE)
if(length(yml) > 0){
meta <- read_yaml(yml)
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
dir_bn <- basename(dir)
fileConn<-file(paste0("songs_md2/",rmd_file_nr_chr,dir_bn,".Rmd"))
paste("#",meta$title) %>%
writeLines(fileConn)
# Todo: include mdchecksums to track changes in files
songs <- list.files(dir, pattern = ".txt",full.names = TRUE)
songs_bn <- basename(songs)
# gives each file an arbitary number
songs_numeric <- map_dbl(songs_bn,~mean(utf8ToInt(.x)))
names(songs_numeric) <- songs
songs_numeric <- sort(songs_numeric)
songs <- names(songs_numeric)
for (song in songs){
song_bn <- basename(song)
song_rl <- song %>%
readLines(warn = FALSE)
chordlines_bool <- song_rl %>%
str_detect("\\[")
# Take only lines where subsequent line is not a chord line
chordlines_bool <- chordlines_bool & lead(!chordlines_bool) & lead(str_length(song_rl)>0)
songlines_subsequent_bool <- lag(chordlines_bool,1,default = FALSE)
chordlines <- song_rl[chordlines_bool]
songlines_subsequent <- song_rl[songlines_subsequent_bool]
songlines_new <- map2_chr(chordlines,songlines_subsequent,function(chordline,songline){
locs <- str_locate_all(chordline,"\\[\\w+\\]")[[1]]
# print(locs)
delta_acc = 0
for(idx in 1:nrow(locs)){
# print(idx)
start <- locs[idx,1]
end <- locs[idx,2]
chord <- str_sub(chordline,start,end)
start_insert <- start + delta_acc
if(idx>1){
} else{
songline_out <- songline
}
songline_out <- addchord(songline_out,start_insert,chord)
delta_acc <- delta_acc+ (end-start+1)
}
songline_out
})
song_rl[songlines_subsequent_bool] <- songlines_new
song_modified <- song_rl[!chordlines_bool]
chordpro_meta_l <- chordpro_meta_all(song_modified)
song_modified <- chordpro_meta_remove(song_modified)
chordpro_environment_l <- chordpro_environment_all(song_modified)
songtitle <- paste(chordpro_meta_l$title,chordpro_meta_l$artist, sep = " - ")
song_modified[chordpro_environment_l$chorus[1]] <- "**Chorus:**"
song_modified[chordpro_environment_l$chorus[2]] <- ""
song_modified[chordpro_environment_l$verse[1]] <- ""
song_modified[chordpro_environment_l$verse[2]] <- ""
song_modified[chordpro_environment_l$tab[1]] <- "```{}"
song_modified[chordpro_environment_l$tab[2]] <- "```"
song_modified[chordpro_environment_l$grid[1]] <- "```{}"
song_modified[chordpro_environment_l$grid[2]] <- "```"
# Add the class "show-chords" to lines with chords
haschords <- str_detect(song_modified,"\\[")
song_modified[haschords] <- paste0("<p class='song show-chords'>",song_modified[haschords],"</p>")
codechunk <- str_detect(song_modified,"```")
# Add an extra backslash to lines with no chords to force linebreak
song_modified[!haschords & !codechunk] <- paste0(song_modified[!haschords & !codechunk],"\\")
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
fileConn<-file(paste0("songs_md2/",paste0(rmd_file_nr_chr, str_replace(song_bn,".txt",".Rmd"))))
song_modified %>%
prepend(paste("##", songtitle)) %>% # TODO: add other metadata
str_replace_all("(\\[(\\w+)\\])","<span class='chord'>\\2</span>") %>%
writeLines(fileConn)
close.connection(fileConn)
}
}
}
chordpro_environment_l
dirs
dirs[4]
dir <- dirs[4]
yml <- list.files(dir,pattern = "(.yaml|.yml)",full.names = TRUE)
yml
meta <- read_yaml(yml)
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
dir_bn <- basename(dir)
fileConn<-file(paste0("songs_md2/",rmd_file_nr_chr,dir_bn,".Rmd"))
songs <- list.files(dir, pattern = ".txt",full.names = TRUE)
songs
song <- songs[4]
song
songs_bn <- basename(songs)
# gives each file an arbitary number
songs_numeric <- map_dbl(songs_bn,~mean(utf8ToInt(.x)))
names(songs_numeric) <- songs
songs_numeric <- sort(songs_numeric)
songs <- names(songs_numeric)
song_bn <- basename(song)
song_rl <- song %>%
readLines(warn = FALSE)
chordlines_bool <- song_rl %>%
str_detect("\\[")
# Take only lines where subsequent line is not a chord line
chordlines_bool <- chordlines_bool & lead(!chordlines_bool) & lead(str_length(song_rl)>0)
songlines_subsequent_bool <- lag(chordlines_bool,1,default = FALSE)
chordlines <- song_rl[chordlines_bool]
songlines_subsequent <- song_rl[songlines_subsequent_bool]
songlines_new <- map2_chr(chordlines,songlines_subsequent,function(chordline,songline){
locs <- str_locate_all(chordline,"\\[\\w+\\]")[[1]]
# print(locs)
delta_acc = 0
for(idx in 1:nrow(locs)){
# print(idx)
start <- locs[idx,1]
end <- locs[idx,2]
chord <- str_sub(chordline,start,end)
start_insert <- start + delta_acc
if(idx>1){
} else{
songline_out <- songline
}
songline_out <- addchord(songline_out,start_insert,chord)
delta_acc <- delta_acc+ (end-start+1)
}
songline_out
})
song_rl[songlines_subsequent_bool] <- songlines_new
song_modified <- song_rl[!chordlines_bool]
chordpro_meta_l <- chordpro_meta_all(song_modified)
song_modified <- chordpro_meta_remove(song_modified)
song_modified
chordpro_environment_l <- chordpro_environment_all(song_modified)
songtitle <- paste(chordpro_meta_l$title,chordpro_meta_l$artist, sep = " - ")
chordpro_environment_l$chorus[1]
song_modified[chordpro_environment_l$chorus[1]] <- "**Chorus:**"
song_modified[chordpro_environment_l$chorus[2]] <- ""
chordpro_environment_l$tab[1]
chordpro_environment_l$grid[1]
chordpro_environment_l$grid
chordpro_environment_all(song_modified)
chordpro_environment_l$grid
seq(1:4,2)
seq(1,4,2)
length(chordpro_environment_l$grid)
song_modified[chordpro_environment_l$grid[seq(1,length(chordpro_environment_l$grid),2)]]
seq(1,length(chordpro_environment_l$grid),2)
song_modified[chordpro_environment_l$grid]
song_modified[chordpro_environment_l$tab]
# Chunk 1
title: ""
pagetitle: "Songs"
site: bookdown::bookdown_site
documentclass: book
link-citations: yes
---
# Chunk 2
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, dev.args=list(bg = "transparent"))
# Chunk 3
output <- knitr::opts_knit$get("rmarkdown.pandoc.to")# html / latex / docx
if(output == "html"){
pander::pandoc.header("Songs {-}",1)
pander::pandoc.image("misc/title.png")
}
# Chunk 4
file.create("docs/.nojekyll")
suppressMessages(library(tabr))
suppressMessages(library(dplyr))
suppressMessages(library(purrr))
suppressMessages(library(ggplot2))
suppressMessages(library(stringr))
suppressMessages(library(gridExtra))
suppressMessages(library(cowplot))
suppressMessages(library(yaml))
test <- TRUE
# Chunk 5
# A wrapper around tabr::plot_chord() which allows multiple chords and styles them in my specific way (4 columns, transparent background etc.)
plot_chords <- function(chords){
# Get the maximum fret-delta of all chords
delta_max <- map_int(chords,function(x){
v <- suppressWarnings(as.integer(str_split(x,"",simplify = TRUE)))
max(v,na.rm = TRUE)-min(v, na.rm = TRUE)
}) %>%
max()
# Make a list of all chord plots
plots <- imap(chords,function(x,y){
v <- min(suppressWarnings(as.integer(str_split(x,"",simplify = TRUE))),na.rm = TRUE)
plot_chord(x,
labels = NULL,
fret_range = c(v,v+delta_max), # so that all chords span the same nr of frets
point_size = 4,
label_size = 3) +
labs(tag = y) +
theme(
panel.background = element_rect(fill = "transparent"), # The theme
plot.background = element_rect(fill = "transparent", color = NA), # bg of the plot
)
})
chordnames <- map(chords, ~.x[2])
plot_grid(plotlist = plots,ncol = 4)
}
# Chunk 6
# Transform all songs in songs_txt into markdown files
addchord <- function(string,pos,chord){
paste0(substr(string, 1, pos-1), chord, substr(string, pos, nchar(string)))
}
chordpro_meta <- function(string,metatag){
regexpression <- paste0("\\{",metatag,":\\s(.+)\\}")
meta_bool <- str_detect(string,regexpression)
str_replace(string[meta_bool],regexpression, "\\1")
}
chordpro_meta_all <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
out2 <- map(tags, ~chordpro_meta(string,.x))
names(out2) <- tags
out2
}
chordpro_meta_remove <- function(string){
tags <- c("title", "subtitle", "artist", "composer", "lyricist", "copyright", "album", "year", "key", "time", "tempo", "duration", "capo", "meta")
remove <- str_detect(string,paste0("(",paste0("\\{",tags,":",collapse = "|"),")"))
string[!remove]
}
chordpro_environment <- function(string,environment_name){
start_bool <- str_detect(string,paste0("\\{start_of_",environment_name))
end_bool <- str_detect(string,paste0("\\{end_of_",environment_name))
c(which(start_bool),which(end_bool))
}
chordpro_environment_all <- function(string){
envs <- c("chorus","verse","tab","grid")
out2 <- map(envs, ~chordpro_environment(string,.x))
names(out2) <- envs
out2
}
# Chunk 7
dirs <- list.dirs("songs_cho/",full.names = TRUE)
# dir <- dirs[4]
rmd_file_nr = 0
for (dir in dirs){
yml <- list.files(dir,pattern = "(.yaml|.yml)",full.names = TRUE)
if(length(yml) > 0){
meta <- read_yaml(yml)
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
dir_bn <- basename(dir)
fileConn<-file(paste0("songs_md2/",rmd_file_nr_chr,dir_bn,".Rmd"))
paste("#",meta$title) %>%
writeLines(fileConn)
close.connection(fileConn)
# Todo: include mdchecksums to track changes in files
songs <- list.files(dir, pattern = ".txt",full.names = TRUE)
song <- songs[4]
songs_bn <- basename(songs)
# gives each file an arbitary number
songs_numeric <- map_dbl(songs_bn,~mean(utf8ToInt(.x)))
names(songs_numeric) <- songs
songs_numeric <- sort(songs_numeric)
songs <- names(songs_numeric)
for (song in songs){
song_bn <- basename(song)
song_rl <- song %>%
readLines(warn = FALSE)
chordlines_bool <- song_rl %>%
str_detect("\\[")
# Take only lines where subsequent line is not a chord line
chordlines_bool <- chordlines_bool & lead(!chordlines_bool) & lead(str_length(song_rl)>0)
songlines_subsequent_bool <- lag(chordlines_bool,1,default = FALSE)
chordlines <- song_rl[chordlines_bool]
songlines_subsequent <- song_rl[songlines_subsequent_bool]
songlines_new <- map2_chr(chordlines,songlines_subsequent,function(chordline,songline){
locs <- str_locate_all(chordline,"\\[\\w+\\]")[[1]]
# print(locs)
delta_acc = 0
for(idx in 1:nrow(locs)){
# print(idx)
start <- locs[idx,1]
end <- locs[idx,2]
chord <- str_sub(chordline,start,end)
start_insert <- start + delta_acc
if(idx>1){
} else{
songline_out <- songline
}
songline_out <- addchord(songline_out,start_insert,chord)
delta_acc <- delta_acc+ (end-start+1)
}
songline_out
})
song_rl[songlines_subsequent_bool] <- songlines_new
song_modified <- song_rl[!chordlines_bool]
chordpro_meta_l <- chordpro_meta_all(song_modified)
song_modified <- chordpro_meta_remove(song_modified)
chordpro_environment_l <- chordpro_environment_all(song_modified)
songtitle <- paste(chordpro_meta_l$title,chordpro_meta_l$artist, sep = " - ")
song_modified[chordpro_environment_l$chorus[1]] <- "**Chorus:**"
song_modified[chordpro_environment_l$chorus[2]] <- ""
song_modified[chordpro_environment_l$verse[1]] <- ""
song_modified[chordpro_environment_l$verse[2]] <- ""
song_modified[chordpro_environment_l$tab] <- "```"
song_modified[chordpro_environment_l$grid] <- "```"
# Add the class "show-chords" to lines with chords
haschords <- str_detect(song_modified,"\\[")
song_modified[haschords] <- paste0("<p class='song show-chords'>",song_modified[haschords],"</p>")
codechunk <- str_detect(song_modified,"```")
# Add an extra backslash to lines with no chords to force linebreak
song_modified[!haschords & !codechunk] <- paste0(song_modified[!haschords & !codechunk],"\\")
rmd_file_nr <- rmd_file_nr+1
rmd_file_nr_chr <- paste0(str_pad(rmd_file_nr,3,pad = "0"),"_")
fileConn<-file(paste0("songs_md2/",paste0(rmd_file_nr_chr, str_replace(song_bn,".txt",".Rmd"))))
song_modified %>%
prepend(paste("##", songtitle)) %>% # TODO: add other metadata
str_replace_all("(\\[(\\w+)\\])","<span class='chord'>\\2</span>") %>%
writeLines(fileConn)
close.connection(fileConn)
}
}
}
